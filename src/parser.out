Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> VAR decl_list stmt_list
Rule 2     program -> stmt_list
Rule 3     decl_list -> decl_list decl
Rule 4     decl_list -> decl
Rule 5     decl -> type id_list SEMI
Rule 6     type -> REAL
Rule 7     type -> INT
Rule 8     id_list -> id_list COMMA ID
Rule 9     id_list -> ID
Rule 10    stmt_list -> stmt_list stmt
Rule 11    stmt_list -> stmt
Rule 12    stmt -> assign_stmt
Rule 13    stmt -> while_stmt
Rule 14    stmt -> if_stmt
Rule 15    assign_stmt -> ID ASSIGN expr SEMI
Rule 16    while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
Rule 17    if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part
Rule 18    else_part -> ELSE LBRACE stmt_list RBRACE
Rule 19    else_part -> empty
Rule 20    relexpr -> expr EQ expr
Rule 21    relexpr -> expr NE expr
Rule 22    relexpr -> expr LT expr
Rule 23    relexpr -> expr LE expr
Rule 24    relexpr -> expr GT expr
Rule 25    relexpr -> expr GE expr
Rule 26    expr -> expr PLUS term
Rule 27    expr -> expr MINUS term
Rule 28    expr -> term
Rule 29    term -> term TIMES factor
Rule 30    term -> term DIVIDE factor
Rule 31    term -> term POWER factor
Rule 32    term -> factor
Rule 33    factor -> LPAREN expr RPAREN
Rule 34    factor -> ID
Rule 35    factor -> NUM
Rule 36    factor -> FLOAT
Rule 37    empty -> <empty>

Terminals, with rules where they appear

ASSIGN               : 15
COMMA                : 8
DIVIDE               : 30
ELSE                 : 18
EQ                   : 20
FLOAT                : 36
GE                   : 25
GT                   : 24
ID                   : 8 9 15 34
IF                   : 17
INT                  : 7
LBRACE               : 16 17 18
LE                   : 23
LPAREN               : 16 17 33
LT                   : 22
MINUS                : 27
NE                   : 21
NUM                  : 35
PLUS                 : 26
POWER                : 31
RBRACE               : 16 17 18
REAL                 : 6
RPAREN               : 16 17 33
SEMI                 : 5 15
TIMES                : 29
VAR                  : 1
WHILE                : 16
error                : 

Nonterminals, with rules where they appear

assign_stmt          : 12
decl                 : 3 4
decl_list            : 1 3
else_part            : 17
empty                : 19
expr                 : 15 20 20 21 21 22 22 23 23 24 24 25 25 26 27 33
factor               : 29 30 31 32
id_list              : 5 8
if_stmt              : 14
program              : 0
relexpr              : 16 17
stmt                 : 10 11
stmt_list            : 1 2 10 16 17 18
term                 : 26 27 28 29 30 31
type                 : 5
while_stmt           : 13

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . VAR decl_list stmt_list
    (2) program -> . stmt_list
    (10) stmt_list -> . stmt_list stmt
    (11) stmt_list -> . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    VAR             shift and go to state 2
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    program                        shift and go to state 1
    stmt_list                      shift and go to state 3
    stmt                           shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 1

    (0) S' -> program .



state 2

    (1) program -> VAR . decl_list stmt_list
    (3) decl_list -> . decl_list decl
    (4) decl_list -> . decl
    (5) decl -> . type id_list SEMI
    (6) type -> . REAL
    (7) type -> . INT

    REAL            shift and go to state 14
    INT             shift and go to state 15

    decl_list                      shift and go to state 11
    decl                           shift and go to state 12
    type                           shift and go to state 13

state 3

    (2) program -> stmt_list .
    (10) stmt_list -> stmt_list . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    $end            reduce using rule 2 (program -> stmt_list .)
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt                           shift and go to state 16
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 4

    (11) stmt_list -> stmt .

    ID              reduce using rule 11 (stmt_list -> stmt .)
    WHILE           reduce using rule 11 (stmt_list -> stmt .)
    IF              reduce using rule 11 (stmt_list -> stmt .)
    $end            reduce using rule 11 (stmt_list -> stmt .)
    RBRACE          reduce using rule 11 (stmt_list -> stmt .)


state 5

    (12) stmt -> assign_stmt .

    ID              reduce using rule 12 (stmt -> assign_stmt .)
    WHILE           reduce using rule 12 (stmt -> assign_stmt .)
    IF              reduce using rule 12 (stmt -> assign_stmt .)
    $end            reduce using rule 12 (stmt -> assign_stmt .)
    RBRACE          reduce using rule 12 (stmt -> assign_stmt .)


state 6

    (13) stmt -> while_stmt .

    ID              reduce using rule 13 (stmt -> while_stmt .)
    WHILE           reduce using rule 13 (stmt -> while_stmt .)
    IF              reduce using rule 13 (stmt -> while_stmt .)
    $end            reduce using rule 13 (stmt -> while_stmt .)
    RBRACE          reduce using rule 13 (stmt -> while_stmt .)


state 7

    (14) stmt -> if_stmt .

    ID              reduce using rule 14 (stmt -> if_stmt .)
    WHILE           reduce using rule 14 (stmt -> if_stmt .)
    IF              reduce using rule 14 (stmt -> if_stmt .)
    $end            reduce using rule 14 (stmt -> if_stmt .)
    RBRACE          reduce using rule 14 (stmt -> if_stmt .)


state 8

    (15) assign_stmt -> ID . ASSIGN expr SEMI

    ASSIGN          shift and go to state 17


state 9

    (16) while_stmt -> WHILE . LPAREN relexpr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 18


state 10

    (17) if_stmt -> IF . LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    LPAREN          shift and go to state 19


state 11

    (1) program -> VAR decl_list . stmt_list
    (3) decl_list -> decl_list . decl
    (10) stmt_list -> . stmt_list stmt
    (11) stmt_list -> . stmt
    (5) decl -> . type id_list SEMI
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (6) type -> . REAL
    (7) type -> . INT
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    REAL            shift and go to state 14
    INT             shift and go to state 15
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt_list                      shift and go to state 20
    decl                           shift and go to state 21
    stmt                           shift and go to state 4
    type                           shift and go to state 13
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 12

    (4) decl_list -> decl .

    REAL            reduce using rule 4 (decl_list -> decl .)
    INT             reduce using rule 4 (decl_list -> decl .)
    ID              reduce using rule 4 (decl_list -> decl .)
    WHILE           reduce using rule 4 (decl_list -> decl .)
    IF              reduce using rule 4 (decl_list -> decl .)


state 13

    (5) decl -> type . id_list SEMI
    (8) id_list -> . id_list COMMA ID
    (9) id_list -> . ID

    ID              shift and go to state 23

    id_list                        shift and go to state 22

state 14

    (6) type -> REAL .

    ID              reduce using rule 6 (type -> REAL .)


state 15

    (7) type -> INT .

    ID              reduce using rule 7 (type -> INT .)


state 16

    (10) stmt_list -> stmt_list stmt .

    ID              reduce using rule 10 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 10 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 10 (stmt_list -> stmt_list stmt .)
    $end            reduce using rule 10 (stmt_list -> stmt_list stmt .)
    RBRACE          reduce using rule 10 (stmt_list -> stmt_list stmt .)


state 17

    (15) assign_stmt -> ID ASSIGN . expr SEMI
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 25
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 18

    (16) while_stmt -> WHILE LPAREN . relexpr RPAREN LBRACE stmt_list RBRACE
    (20) relexpr -> . expr EQ expr
    (21) relexpr -> . expr NE expr
    (22) relexpr -> . expr LT expr
    (23) relexpr -> . expr LE expr
    (24) relexpr -> . expr GT expr
    (25) relexpr -> . expr GE expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    relexpr                        shift and go to state 31
    expr                           shift and go to state 32
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 19

    (17) if_stmt -> IF LPAREN . relexpr RPAREN LBRACE stmt_list RBRACE else_part
    (20) relexpr -> . expr EQ expr
    (21) relexpr -> . expr NE expr
    (22) relexpr -> . expr LT expr
    (23) relexpr -> . expr LE expr
    (24) relexpr -> . expr GT expr
    (25) relexpr -> . expr GE expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    relexpr                        shift and go to state 33
    expr                           shift and go to state 32
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 20

    (1) program -> VAR decl_list stmt_list .
    (10) stmt_list -> stmt_list . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    $end            reduce using rule 1 (program -> VAR decl_list stmt_list .)
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt                           shift and go to state 16
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 21

    (3) decl_list -> decl_list decl .

    REAL            reduce using rule 3 (decl_list -> decl_list decl .)
    INT             reduce using rule 3 (decl_list -> decl_list decl .)
    ID              reduce using rule 3 (decl_list -> decl_list decl .)
    WHILE           reduce using rule 3 (decl_list -> decl_list decl .)
    IF              reduce using rule 3 (decl_list -> decl_list decl .)


state 22

    (5) decl -> type id_list . SEMI
    (8) id_list -> id_list . COMMA ID

    SEMI            shift and go to state 34
    COMMA           shift and go to state 35


state 23

    (9) id_list -> ID .

    SEMI            reduce using rule 9 (id_list -> ID .)
    COMMA           reduce using rule 9 (id_list -> ID .)


state 24

    (34) factor -> ID .

    TIMES           reduce using rule 34 (factor -> ID .)
    DIVIDE          reduce using rule 34 (factor -> ID .)
    POWER           reduce using rule 34 (factor -> ID .)
    SEMI            reduce using rule 34 (factor -> ID .)
    PLUS            reduce using rule 34 (factor -> ID .)
    MINUS           reduce using rule 34 (factor -> ID .)
    EQ              reduce using rule 34 (factor -> ID .)
    NE              reduce using rule 34 (factor -> ID .)
    LT              reduce using rule 34 (factor -> ID .)
    LE              reduce using rule 34 (factor -> ID .)
    GT              reduce using rule 34 (factor -> ID .)
    GE              reduce using rule 34 (factor -> ID .)
    RPAREN          reduce using rule 34 (factor -> ID .)


state 25

    (15) assign_stmt -> ID ASSIGN expr . SEMI
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    SEMI            shift and go to state 36
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 26

    (28) expr -> term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor
    (31) term -> term . POWER factor

    SEMI            reduce using rule 28 (expr -> term .)
    PLUS            reduce using rule 28 (expr -> term .)
    MINUS           reduce using rule 28 (expr -> term .)
    EQ              reduce using rule 28 (expr -> term .)
    NE              reduce using rule 28 (expr -> term .)
    LT              reduce using rule 28 (expr -> term .)
    LE              reduce using rule 28 (expr -> term .)
    GT              reduce using rule 28 (expr -> term .)
    GE              reduce using rule 28 (expr -> term .)
    RPAREN          reduce using rule 28 (expr -> term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 27

    (32) term -> factor .

    TIMES           reduce using rule 32 (term -> factor .)
    DIVIDE          reduce using rule 32 (term -> factor .)
    POWER           reduce using rule 32 (term -> factor .)
    SEMI            reduce using rule 32 (term -> factor .)
    PLUS            reduce using rule 32 (term -> factor .)
    MINUS           reduce using rule 32 (term -> factor .)
    EQ              reduce using rule 32 (term -> factor .)
    NE              reduce using rule 32 (term -> factor .)
    LT              reduce using rule 32 (term -> factor .)
    LE              reduce using rule 32 (term -> factor .)
    GT              reduce using rule 32 (term -> factor .)
    GE              reduce using rule 32 (term -> factor .)
    RPAREN          reduce using rule 32 (term -> factor .)


state 28

    (33) factor -> LPAREN . expr RPAREN
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 42
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 29

    (35) factor -> NUM .

    TIMES           reduce using rule 35 (factor -> NUM .)
    DIVIDE          reduce using rule 35 (factor -> NUM .)
    POWER           reduce using rule 35 (factor -> NUM .)
    SEMI            reduce using rule 35 (factor -> NUM .)
    PLUS            reduce using rule 35 (factor -> NUM .)
    MINUS           reduce using rule 35 (factor -> NUM .)
    EQ              reduce using rule 35 (factor -> NUM .)
    NE              reduce using rule 35 (factor -> NUM .)
    LT              reduce using rule 35 (factor -> NUM .)
    LE              reduce using rule 35 (factor -> NUM .)
    GT              reduce using rule 35 (factor -> NUM .)
    GE              reduce using rule 35 (factor -> NUM .)
    RPAREN          reduce using rule 35 (factor -> NUM .)


state 30

    (36) factor -> FLOAT .

    TIMES           reduce using rule 36 (factor -> FLOAT .)
    DIVIDE          reduce using rule 36 (factor -> FLOAT .)
    POWER           reduce using rule 36 (factor -> FLOAT .)
    SEMI            reduce using rule 36 (factor -> FLOAT .)
    PLUS            reduce using rule 36 (factor -> FLOAT .)
    MINUS           reduce using rule 36 (factor -> FLOAT .)
    EQ              reduce using rule 36 (factor -> FLOAT .)
    NE              reduce using rule 36 (factor -> FLOAT .)
    LT              reduce using rule 36 (factor -> FLOAT .)
    LE              reduce using rule 36 (factor -> FLOAT .)
    GT              reduce using rule 36 (factor -> FLOAT .)
    GE              reduce using rule 36 (factor -> FLOAT .)
    RPAREN          reduce using rule 36 (factor -> FLOAT .)


state 31

    (16) while_stmt -> WHILE LPAREN relexpr . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 43


state 32

    (20) relexpr -> expr . EQ expr
    (21) relexpr -> expr . NE expr
    (22) relexpr -> expr . LT expr
    (23) relexpr -> expr . LE expr
    (24) relexpr -> expr . GT expr
    (25) relexpr -> expr . GE expr
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    EQ              shift and go to state 44
    NE              shift and go to state 45
    LT              shift and go to state 46
    LE              shift and go to state 47
    GT              shift and go to state 48
    GE              shift and go to state 49
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 33

    (17) if_stmt -> IF LPAREN relexpr . RPAREN LBRACE stmt_list RBRACE else_part

    RPAREN          shift and go to state 50


state 34

    (5) decl -> type id_list SEMI .

    REAL            reduce using rule 5 (decl -> type id_list SEMI .)
    INT             reduce using rule 5 (decl -> type id_list SEMI .)
    ID              reduce using rule 5 (decl -> type id_list SEMI .)
    WHILE           reduce using rule 5 (decl -> type id_list SEMI .)
    IF              reduce using rule 5 (decl -> type id_list SEMI .)


state 35

    (8) id_list -> id_list COMMA . ID

    ID              shift and go to state 51


state 36

    (15) assign_stmt -> ID ASSIGN expr SEMI .

    ID              reduce using rule 15 (assign_stmt -> ID ASSIGN expr SEMI .)
    WHILE           reduce using rule 15 (assign_stmt -> ID ASSIGN expr SEMI .)
    IF              reduce using rule 15 (assign_stmt -> ID ASSIGN expr SEMI .)
    $end            reduce using rule 15 (assign_stmt -> ID ASSIGN expr SEMI .)
    RBRACE          reduce using rule 15 (assign_stmt -> ID ASSIGN expr SEMI .)


state 37

    (26) expr -> expr PLUS . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    term                           shift and go to state 52
    factor                         shift and go to state 27

state 38

    (27) expr -> expr MINUS . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    term                           shift and go to state 53
    factor                         shift and go to state 27

state 39

    (29) term -> term TIMES . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    factor                         shift and go to state 54

state 40

    (30) term -> term DIVIDE . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    factor                         shift and go to state 55

state 41

    (31) term -> term POWER . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    factor                         shift and go to state 56

state 42

    (33) factor -> LPAREN expr . RPAREN
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          shift and go to state 57
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 43

    (16) while_stmt -> WHILE LPAREN relexpr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 58


state 44

    (20) relexpr -> expr EQ . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 59
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 45

    (21) relexpr -> expr NE . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 60
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 46

    (22) relexpr -> expr LT . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 61
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 47

    (23) relexpr -> expr LE . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 62
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 48

    (24) relexpr -> expr GT . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 63
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 49

    (25) relexpr -> expr GE . expr
    (26) expr -> . expr PLUS term
    (27) expr -> . expr MINUS term
    (28) expr -> . term
    (29) term -> . term TIMES factor
    (30) term -> . term DIVIDE factor
    (31) term -> . term POWER factor
    (32) term -> . factor
    (33) factor -> . LPAREN expr RPAREN
    (34) factor -> . ID
    (35) factor -> . NUM
    (36) factor -> . FLOAT

    LPAREN          shift and go to state 28
    ID              shift and go to state 24
    NUM             shift and go to state 29
    FLOAT           shift and go to state 30

    expr                           shift and go to state 64
    term                           shift and go to state 26
    factor                         shift and go to state 27

state 50

    (17) if_stmt -> IF LPAREN relexpr RPAREN . LBRACE stmt_list RBRACE else_part

    LBRACE          shift and go to state 65


state 51

    (8) id_list -> id_list COMMA ID .

    SEMI            reduce using rule 8 (id_list -> id_list COMMA ID .)
    COMMA           reduce using rule 8 (id_list -> id_list COMMA ID .)


state 52

    (26) expr -> expr PLUS term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor
    (31) term -> term . POWER factor

    SEMI            reduce using rule 26 (expr -> expr PLUS term .)
    PLUS            reduce using rule 26 (expr -> expr PLUS term .)
    MINUS           reduce using rule 26 (expr -> expr PLUS term .)
    EQ              reduce using rule 26 (expr -> expr PLUS term .)
    NE              reduce using rule 26 (expr -> expr PLUS term .)
    LT              reduce using rule 26 (expr -> expr PLUS term .)
    LE              reduce using rule 26 (expr -> expr PLUS term .)
    GT              reduce using rule 26 (expr -> expr PLUS term .)
    GE              reduce using rule 26 (expr -> expr PLUS term .)
    RPAREN          reduce using rule 26 (expr -> expr PLUS term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 53

    (27) expr -> expr MINUS term .
    (29) term -> term . TIMES factor
    (30) term -> term . DIVIDE factor
    (31) term -> term . POWER factor

    SEMI            reduce using rule 27 (expr -> expr MINUS term .)
    PLUS            reduce using rule 27 (expr -> expr MINUS term .)
    MINUS           reduce using rule 27 (expr -> expr MINUS term .)
    EQ              reduce using rule 27 (expr -> expr MINUS term .)
    NE              reduce using rule 27 (expr -> expr MINUS term .)
    LT              reduce using rule 27 (expr -> expr MINUS term .)
    LE              reduce using rule 27 (expr -> expr MINUS term .)
    GT              reduce using rule 27 (expr -> expr MINUS term .)
    GE              reduce using rule 27 (expr -> expr MINUS term .)
    RPAREN          reduce using rule 27 (expr -> expr MINUS term .)
    TIMES           shift and go to state 39
    DIVIDE          shift and go to state 40
    POWER           shift and go to state 41


state 54

    (29) term -> term TIMES factor .

    TIMES           reduce using rule 29 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 29 (term -> term TIMES factor .)
    POWER           reduce using rule 29 (term -> term TIMES factor .)
    SEMI            reduce using rule 29 (term -> term TIMES factor .)
    PLUS            reduce using rule 29 (term -> term TIMES factor .)
    MINUS           reduce using rule 29 (term -> term TIMES factor .)
    EQ              reduce using rule 29 (term -> term TIMES factor .)
    NE              reduce using rule 29 (term -> term TIMES factor .)
    LT              reduce using rule 29 (term -> term TIMES factor .)
    LE              reduce using rule 29 (term -> term TIMES factor .)
    GT              reduce using rule 29 (term -> term TIMES factor .)
    GE              reduce using rule 29 (term -> term TIMES factor .)
    RPAREN          reduce using rule 29 (term -> term TIMES factor .)


state 55

    (30) term -> term DIVIDE factor .

    TIMES           reduce using rule 30 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 30 (term -> term DIVIDE factor .)
    POWER           reduce using rule 30 (term -> term DIVIDE factor .)
    SEMI            reduce using rule 30 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 30 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 30 (term -> term DIVIDE factor .)
    EQ              reduce using rule 30 (term -> term DIVIDE factor .)
    NE              reduce using rule 30 (term -> term DIVIDE factor .)
    LT              reduce using rule 30 (term -> term DIVIDE factor .)
    LE              reduce using rule 30 (term -> term DIVIDE factor .)
    GT              reduce using rule 30 (term -> term DIVIDE factor .)
    GE              reduce using rule 30 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 30 (term -> term DIVIDE factor .)


state 56

    (31) term -> term POWER factor .

    TIMES           reduce using rule 31 (term -> term POWER factor .)
    DIVIDE          reduce using rule 31 (term -> term POWER factor .)
    POWER           reduce using rule 31 (term -> term POWER factor .)
    SEMI            reduce using rule 31 (term -> term POWER factor .)
    PLUS            reduce using rule 31 (term -> term POWER factor .)
    MINUS           reduce using rule 31 (term -> term POWER factor .)
    EQ              reduce using rule 31 (term -> term POWER factor .)
    NE              reduce using rule 31 (term -> term POWER factor .)
    LT              reduce using rule 31 (term -> term POWER factor .)
    LE              reduce using rule 31 (term -> term POWER factor .)
    GT              reduce using rule 31 (term -> term POWER factor .)
    GE              reduce using rule 31 (term -> term POWER factor .)
    RPAREN          reduce using rule 31 (term -> term POWER factor .)


state 57

    (33) factor -> LPAREN expr RPAREN .

    TIMES           reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    POWER           reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    SEMI            reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    EQ              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    NE              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    LT              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    LE              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    GT              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    GE              reduce using rule 33 (factor -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 33 (factor -> LPAREN expr RPAREN .)


state 58

    (16) while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE . stmt_list RBRACE
    (10) stmt_list -> . stmt_list stmt
    (11) stmt_list -> . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt_list                      shift and go to state 66
    stmt                           shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 59

    (20) relexpr -> expr EQ expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 20 (relexpr -> expr EQ expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 60

    (21) relexpr -> expr NE expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 21 (relexpr -> expr NE expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 61

    (22) relexpr -> expr LT expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 22 (relexpr -> expr LT expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 62

    (23) relexpr -> expr LE expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 23 (relexpr -> expr LE expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 63

    (24) relexpr -> expr GT expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 24 (relexpr -> expr GT expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 64

    (25) relexpr -> expr GE expr .
    (26) expr -> expr . PLUS term
    (27) expr -> expr . MINUS term

    RPAREN          reduce using rule 25 (relexpr -> expr GE expr .)
    PLUS            shift and go to state 37
    MINUS           shift and go to state 38


state 65

    (17) if_stmt -> IF LPAREN relexpr RPAREN LBRACE . stmt_list RBRACE else_part
    (10) stmt_list -> . stmt_list stmt
    (11) stmt_list -> . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt_list                      shift and go to state 67
    stmt                           shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 66

    (16) while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list . RBRACE
    (10) stmt_list -> stmt_list . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    RBRACE          shift and go to state 68
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt                           shift and go to state 16
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 67

    (17) if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list . RBRACE else_part
    (10) stmt_list -> stmt_list . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    RBRACE          shift and go to state 69
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt                           shift and go to state 16
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 68

    (16) while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .

    ID              reduce using rule 16 (while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 16 (while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 16 (while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .)
    $end            reduce using rule 16 (while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 16 (while_stmt -> WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE .)


state 69

    (17) if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE . else_part
    (18) else_part -> . ELSE LBRACE stmt_list RBRACE
    (19) else_part -> . empty
    (37) empty -> .

    ELSE            shift and go to state 71
    ID              reduce using rule 37 (empty -> .)
    WHILE           reduce using rule 37 (empty -> .)
    IF              reduce using rule 37 (empty -> .)
    $end            reduce using rule 37 (empty -> .)
    RBRACE          reduce using rule 37 (empty -> .)

    else_part                      shift and go to state 70
    empty                          shift and go to state 72

state 70

    (17) if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .

    ID              reduce using rule 17 (if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .)
    WHILE           reduce using rule 17 (if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .)
    IF              reduce using rule 17 (if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .)
    $end            reduce using rule 17 (if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .)
    RBRACE          reduce using rule 17 (if_stmt -> IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part .)


state 71

    (18) else_part -> ELSE . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 73


state 72

    (19) else_part -> empty .

    ID              reduce using rule 19 (else_part -> empty .)
    WHILE           reduce using rule 19 (else_part -> empty .)
    IF              reduce using rule 19 (else_part -> empty .)
    $end            reduce using rule 19 (else_part -> empty .)
    RBRACE          reduce using rule 19 (else_part -> empty .)


state 73

    (18) else_part -> ELSE LBRACE . stmt_list RBRACE
    (10) stmt_list -> . stmt_list stmt
    (11) stmt_list -> . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt_list                      shift and go to state 74
    stmt                           shift and go to state 4
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 74

    (18) else_part -> ELSE LBRACE stmt_list . RBRACE
    (10) stmt_list -> stmt_list . stmt
    (12) stmt -> . assign_stmt
    (13) stmt -> . while_stmt
    (14) stmt -> . if_stmt
    (15) assign_stmt -> . ID ASSIGN expr SEMI
    (16) while_stmt -> . WHILE LPAREN relexpr RPAREN LBRACE stmt_list RBRACE
    (17) if_stmt -> . IF LPAREN relexpr RPAREN LBRACE stmt_list RBRACE else_part

    RBRACE          shift and go to state 75
    ID              shift and go to state 8
    WHILE           shift and go to state 9
    IF              shift and go to state 10

    stmt                           shift and go to state 16
    assign_stmt                    shift and go to state 5
    while_stmt                     shift and go to state 6
    if_stmt                        shift and go to state 7

state 75

    (18) else_part -> ELSE LBRACE stmt_list RBRACE .

    ID              reduce using rule 18 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 18 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    IF              reduce using rule 18 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    $end            reduce using rule 18 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    RBRACE          reduce using rule 18 (else_part -> ELSE LBRACE stmt_list RBRACE .)

